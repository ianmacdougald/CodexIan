TITLE::Codices Guide
summary::Guide to working with the Codices quark
categories::Libraries>Codices
related::Classes/Codex
keyword::codex, codices

section::Description
The Codices quark establishes a framework for developing class interfaces that use arbitrarily defined scriptable modules. For instance, a class written in this framework that iteratively evaluates a function within a routine might implement only the routine, leaving the function itself to be defined later by the user. As a result, an object of this class can support any number of diverse configurations without compromising the functionality of the class itself.

The framework aims to support a best-of-both-worlds situation that balances the specficity of a compiled class's interface with the open-ended potential of scripting. link::Classes/Codex:: coordinates these operations on behalf of its subclasses and maintains the directory of modules.

section::Managing modules

Each class that inherits from Codex will have its modules stored in a central directory on the machine. The modules themselves are organized in layers of subfolders that are specified on a per-class-per-collection basis. The path to the directory can be gotten and set through link::Classes/Codex#*directory::. If the path to the directory of modules is reset, the new configuration will persist across sessions of the link::Classes/Interpreter::.

note::Be sure to configure the path to the modules' directory. By default, the directory is stored in the folder of this quark.
code::
//Check where the directory is.
Codex.directory.postln;

//Replace this path with something you prefer.
Codex.directory = "~/Documents/scmodules".standardizePath;
::
::
An outline of the directory looks like this:

Module Directory
tree::
	##Class 0
		tree::
			##Module folder
				tree::
					##Module
					##Module
					##Module
				::
			##Module folder
				tree::
					##Module
					##Module
					##Module
				::
		::
	##Class 1
		tree::
			##Module folder
			tree::
				##Module
			::
		::
::

subsection::Class folders
Class folders are generated automatically. However, the circumstances regarding when that happens vary. For instance, a class that contains references to preconfigured versions of its modules will create both its class folder when sclang is recompiled as well as subfolders populated with copies of these modules, and this process will be repeated if any of these folders are deleted. If no versions are specified, then once a class is instanced for the first time the framework will generate both the class folder and a folder of modules filled with templates.

subsection::Module folders
Modules are stored as teletype::.scd:: files within the subfolders of each class folder; each of these subfolders contains variations of the modules templated by the class. A given class will expect that modules representing specific sclang objects exist but does not need to know emphasis::how:: they exist. The module loaded from the file teletype::default/sequence.scd:: can be different from the one loaded from the file teletype::experimental/sequence.scd:: so long as both scripts return an object of the same type.

There is no prescribed limit to the number of modular variations that can exist per class. An instance of a subclass of Codex is told to load one of these variatoins either by supplying a symbol to the teletype::moduleSet:: argument of link::Classes/Codex#*new:: or by setting the value of the field link::Classes/Codex#-moduleSet::.
note::To see all available module sets for a given class, use the method link::Classes/Codex#*moduleSets#*moduleSets::.::
In both cases, the user has an opportunity to point to a different set of modules by supplying a second argument. If the first set of modules does not exist but the second set does, then the second set will be copied into the first. If the second set also does not exist, both sets will be generated from templates.

subsection::Modules
When a set of modules is requested for the first time, its associated scripts will be compiled as functions and stored in a cache maintained by Codex. Subsequently, these functions will be evaluated and returned to each instance that is requesting modules (see link::Classes/CodexModules::).

If the source file a module is edited (and saved), calling link::Classes/Codex#-reloadScripts:: will reload the scripts into the cache before evaluating/copying them into the instance that called the method.
If multiple instances of the class using the same moduleSet exist, their modules can then be updated using the method link::Classes/Codex#-reloadModules::.
This process does not require recompiling sclang.

subsection::SynthDef names
Codex pays special attention to link::Classes/SynthDef:: modules, specifically managing their names to prevent one set of modules from overwriting the SynthDef from another set. For this reason, it is best not to use the method link::Classes/SynthDef#add#.add:: or link::Classes/SynthDef#send#.send:: or whatever else when defining the module. Let Codex do that for you!

SynthDefs are renamed in the following format: teletype::\ClassName_moduleSet_originalName::. For instance, if a SynthDef is called "earth" in a set "milkyWay" for the hypothetical class "Universe," then Codex will rename that SynthDef to teletype::\Universe_milkyWay_earth.:: If that module set is then cloned into a new one called "andromeda," its SynthDef would be renamed to teletype::\Universe_andromeda_earth::.


subsection::Contributing versions of modules.
Codex supports the ability to ship any of its subclasses with sets of preconfigured modules. This is done by overwriting the method link::Classes/Codex#*contribute#*contribute::, which is passed a link::Classes/Dictionary:: as an argument.
Folder paths added to this dictionary will copy their contents to the relevant folders when sclang is recompiled. These modules can then be accessed using the same key that was originally supplied to the dictionary.

If you want to contribute modules you've developed to a project/quark that uses the Codex framework, there are five short steps for doing so:

numberedlist::
##Checkout a new branch of your clone of the project.
##Add your version of the modules to the project folder.
##Reference your modules using the method described above.
##Commit your changes.
##Submit a pull request for the project.
::

By implementing this framework as a platform that publishes diverse approaches to common projects, my hope is to promote a collaborative music-making process that mirros the ethos of the libre/open-source software movements in which the SuperCollider project itself is developed. More information about how to contribute either to Codex-based projects or to SuperCollider can be found with the following link:
link::https://supercollider.github.io/contributing/::.


section::CodexExample
Developing a class that inherits from Codex is relatively simple. No constructor is needed. The only requirement is that the developer fill out the method link::Classes/Codex#*makeTemplates::, which is passed an instance of link::Classes/CodexTemplater:: as an argument. In fact, it is this method that defines the modules of a class. A class that requires a pattern using the key teletype::\sequence:: must tell the CodexTemplater instance to generate a pattern template with the name "sequence".

A basic implementation of a class that inherits from Codex is displayed below. Two modules are defined â€” a link::Classes/Pbind:: called teletype::\sequence:: and a link::Classes/SynthDef:: called teletype::\synthDef::, and the class implements two other methods for playing and stoppig the pattern.

code::
CodexExample : Codex {
	var player;

	//*contribute is passed a Dictionary instance for adding versions.
	//The key of each entry will become the name of the new module folder.
	//And the path points to where the original modules are stored.
	*contribute { | versions |
		var toQuark = Main.packages.asDict.at(\Codices);
		var toExample = toQuark+/+"Examples/Modules";

		versions.add(\example -> toExample);
	}

	*makeTemplates { | templater |
		templater.pattern( "sequence" );
		templater.synthDef( "synthDef" );
	}

	//initCodex is called immediately after modules are loaded into the class.
	//Initialize instance variables here if you don't want to rewrite the constructor.
	initCodex {}

	play { | clock(TempoClock.default) |
		if(player.isPlaying.not, {
			player = modules.sequence.play(clock, modules.asEvent);
		});
	}

	stop {
		if(player.isPlaying, {
			player.stop;
		});
	}
}
::

subsection::Usage
Below represents code for interacting with the class whose implementation is displayed immediately above.
code::
//Instance CodexExample using the moduleSet 'example'.
x = CodexExample.new(\example);

//Insepct the modules.
x.modules.postln;

//See the moduleSets available to the class.
CodexExample.moduleSets;

//Open the currently loaded scripts.
//This is only supported for scide, scvim, and scnvim.
x.openModules;

//Hear some sounds.
s.boot;
x.play;

//Stop some sounds.
x.stop;

//Make a new set of modules.
x.moduleSet = \test;

//There are now more moduleSets available to the class.
CodexExample.moduleSets.postln;

//Open the \test set of modules.
x.openModules;

//If you edit them, load the changes back into the instance.
x.reloadScripts;

//Then hear your changes.
x.play;

//Then stop.
x.stop;

//Inspect the name of the SynthDef.
x.modules.synthDef.name.postln;

//Or use a shortcut.
x.synthDef.name.postln;

//You can switch back and forth between existing modules too.
x.moduleSet = \example;

//Check the SynthDef name.
x.synthDef.name.postln;

//You can clone a new set of modules from an existing one.
x.moduleSet_(\test2, \example);

//Check the SynthDef name.
x.synthDef.name.postln;

//Open the new modules to see that the modules have been copied.
x.openModules;
::

section::But wait! There's more!

For more classes and frameworks that are based on the procedures outlined in this guide, check out the following link::https://github.com/ianmacdougald/CodicesMore##quark::. It is made up of still-in-the-works tools for composing electronic music, quickly fabricating composite GUIs, making virtual instruments, and more!
